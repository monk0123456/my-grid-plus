(def line "select a.bonus_type + b.region_code -12,a.first_year_commission,b.region_code,a.persist_month from diamond_award_history a,n_sal_tmp b where a.agent_no=c_empno and b.agentno=c_empno and a.commission_month=to_char(p_year)||lpad(to_char(p_month ),2,'0')and b.pol_yr=p_year and b.pol_month=p_month and a.employee_type='01' and a.diamond_type='01'")

(def lst (my-lexical/to-back line))
(def segment (my-lexical/get-segments-list lst))

(def query-items (-> segment :query-items))

(get-item-rv (reverse (first query-items)))

(defn get-item-rv [[f & rs]]
    (cond
        (= (count (concat [f] rs)) 1) {:item-lst (concat [f]) :alias nil}
        (my-lexical/is-eq? (first rs) "as") {:item-lst (reverse (rest rs)) :alias f}
        (and (= (count rs) 1) (= (first rs) (last rs))) {:item-lst (first rs) :alias f}
        (and (my-lexical/is-word? f) (= (first rs) ")")) {:item-lst (reverse rs) :alias f}
        (and (my-lexical/is-word? f) (my-lexical/is-word? (first rs)) (not (my-lexical/is-word? (second rs))) (> (count rs) 2)) {:item-lst (reverse rs) :alias f}
        :else
        {:item-lst (reverse (concat [f] rs)) :alias nil}
        ))


;(def line "select a.bonus_type + b.region_code -12 from meta.diamond_award_history a,public.n_sal_tmp as b, wudafu w, ma.wudafu, private.wudafu dafu, meiyy as myy, wudagui where a.agent_no=c_empno ")
;(def line "select m.dataset_name from MY_META.my_dataset as m INNER JOIN MY_META.my_meta_tables o on m.id = o.data_set_id where o.table_name='products'")
(def line "select m.code from my_select_views as m INNER JOIN my_group_view as gv on m.id = gv.view_id INNER JOIN my_dataset as ds on ds.id = m.data_set_id WHERE gv.my_group_id = 1 and m.table_name = 'orders' and ds.dataset_name = 'wudagui' and gv.view_type = '查'")

(def lst (my-lexical/to-back line))
(def segment (my-lexical/get-segments-list lst))

(def query-items (-> segment :query-items))
(def table-items (-> segment :table-items))

(defn get-table-items [table-items]
    (letfn [(is-select?
                ([lst] (if (some? lst)
                           (if (and (= (first lst) "(") (= (last lst) ")"))
                               (let [m (is-select? (rest lst) [])]
                                   (if (and (some? m) (> (count m) 0))
                                       (when-let [sql_objs (get-my-sql-to-ast m)]
                                           (if (> (count sql_objs) 0) true)))))))
                ([[f & r] my-lst]
                 (if (empty? r) my-lst (recur r (concat my-lst [f])))))
            (get-select-line
                ([lst] (if (some? lst) (get-select-line (rest lst) [])))
                ([[f & r] my-lst]
                 (if (empty? r) my-lst (recur r (concat my-lst [f])))))
            ; 处理 join 类型的
            (table-join [[f & rs]]
                (if (some? f)
                    (cond (contains? f :tables)
                          (let [{tables :tables} f]
                              (cond (= (count tables) 1)(concat [{:schema_name "" :table_name (first tables) :table_alias ""}] (table-join rs))
                                    (= (count tables) 2) (concat [{:schema_name "" :table_name (first tables) :table_alias (last tables)}] (table-join rs))
                                    (and (= (count tables) 3) (my-lexical/is-eq? (nth tables 1) "as")) (concat [{:schema_name "" :table_name (first tables) :table_alias (last tables)}] (table-join rs))
                                    (and (= (count tables) 3) (= (nth tables 1) ".")) (concat [{:schema_name (first tables) :table_name (last tables) :table_alias ""}] (table-join rs))
                                    (and (= (count tables) 4) (= (nth tables 1) ".")) (concat [{:schema_name (first tables) :table_name (nth tables 2) :table_alias (last tables)}] (table-join rs))
                                    (and (= (count tables) 5) (= (nth tables 1) ".") (my-lexical/is-eq? (nth tables 3) "as")) (concat [{:schema_name (first tables) :table_name (nth tables 2) :table_alias (last tables)}] (table-join rs))
                                    :else
                                    (throw (Exception. "sql 语句错误！from 关键词之后"))
                                    ))
                          (contains? f :join) (concat [{:join (-> f :join)}] (table-join rs))
                          (contains? f :on) (cons {:on (get-token (get f :on))} (table-join rs))
                          )))
            ; 处理 table-items
            (get-table
                ([lst] (when-let [m (get-table (reverse lst) [] [])]
                           (if (> (count m) 1) (reverse m) m)))
                ([[f & rs] stack lst]
                 (if (some? f)
                     (cond (and (my-lexical/is-eq? f "on") (= (count stack) 0)) (if (> (count lst) 0) (concat [{:on (reverse lst)}] (get-table rs stack [])) (get-table rs stack []))
                           (and (my-lexical/is-eq? f "join") (contains? #{"left" "inner" "right"} (str/lower-case (first rs))) (= (count stack) 0)) (if (> (count lst) 0) (concat [{:tables (reverse lst)}] [{:join (str/join [(first rs) " " f])}] (get-table (rest rs) stack [])) (get-table (rest rs) stack []))
                           (and (my-lexical/is-eq? f "join") (not (contains? #{"left" "inner" "right"} (str/lower-case (first rs)))) (= (count stack) 0)) (if (> (count lst) 0) (concat [{:tables (reverse lst)}] [{:join f}] (get-table rs stack [])) (get-table rs stack []))
                           (= f ")") (get-table rs (conj stack f) (conj lst f))
                           (= f "(") (get-table rs (pop stack) (conj lst f))
                           :else
                           (get-table rs stack (conj lst f))
                           )
                     (if (> (count lst) 0) [{:tables (reverse lst)}]))))
            (to-table-item [lst]
                (cond (= (count lst) 1) {:schema_name "" :table_name (first lst) :table_alias ""}
                      (= (count lst) 2) {:schema_name "" :table_name (first lst) :table_alias (last lst)}
                      (= (count lst) 3) (cond (my-lexical/is-eq? (second lst) "as") {:schema_name "" :table_name (first lst) :table_alias (last lst)}
                                              (= (second lst) ".") {:schema_name (first lst) :table_name (last lst) :table_alias ""})
                      (and (= (count lst) 4) (= (second lst) ".")) {:schema_name (first lst) :table_name (nth lst 2) :table_alias (last lst)}
                      (and (= (count lst) 5) (my-lexical/is-eq? (nth lst 3) "as")) {:schema_name (first lst) :table_name (nth lst 2) :table_alias (last lst)}
                      :else
                      (get-query-items lst)
                      ))
            ; 处理逗号类型的
            (table-comma
                [lst]
                (if (and (string? lst) (my-lexical/is-eq? lst ","))
                    (get-token-line lst)
                    (to-table-item lst)))
            ]
        (if (= (count table-items) 1)
            (let [m (first table-items)]
                (cond (string? m) (concat [{:schema_name "", :table_name m, :table_alias ""}])
                      (and (my-lexical/is-seq? m) (is-select? m)) {:parenthesis (get-my-sql-to-ast (get-select-line m))}
                      :else
                      (if (my-lexical/is-contains? (first table-items) "join")
                          (do
                              (println (get-table (first table-items)))
                              (table-join (get-table (first table-items))))
                          (map table-comma table-items))))
            (map table-comma table-items)))
    )

table-items
(get-table-items table-items)
;(get-token (my-lexical/to-back "m.id = o.data_set_id"))
;(def table-items (-> segment :table-items))