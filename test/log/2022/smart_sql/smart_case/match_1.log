(defn get-vs-pair [lst]
    (loop [index (- (count lst) 1) stack-lst [] rs []]
        (if (> index -1)
            (let [f (nth lst index)]
                (cond (= f "}") (recur -1 [] (conj rs (take (+ index 1) lst) (reverse stack-lst)))
                      (= f ";") (recur -1 [] (conj rs (take (+ index 1) lst) (reverse stack-lst)))
                      :else
                      (recur (- index 1) (conj stack-lst f) rs)
                      ))
            rs)))

(defn split-pair-item-ex
    ([lst] (split-pair-item-ex lst [] nil [] [] []))
    ([[f & r] stack mid-small stack-lst k-v lst]
     (if (some? f)
         (cond (= f "(") (if (or (= mid-small "mid") (= mid-small "big"))
                             (recur r stack mid-small (conj stack-lst f) k-v lst)
                             (recur r (conj stack f) "small" (conj stack-lst f) k-v lst))
               (= f "[") (if (or (= mid-small "small") (= mid-small "big"))
                             (recur r stack mid-small (conj stack-lst f) k-v lst)
                             (recur r (conj stack f) "mid" (conj stack-lst f) k-v lst))
               (= f "{") (if (or (= mid-small "mid") (= mid-small "small"))
                             (recur r stack mid-small (conj stack-lst f) k-v lst)
                             (recur r (conj stack f) "big" (conj stack-lst f) k-v lst))
               (= f ")") (cond (and (= (count stack) 1) (= mid-small "small")) (recur r [] nil (conj stack-lst f) k-v lst)
                               (and (> (count stack) 1) (= mid-small "small")) (recur r (pop stack) "small" (conj stack-lst f) k-v lst)
                               (not (= mid-small "small")) (recur r stack mid-small (conj stack-lst f) k-v lst)
                               )
               (= f "]") (cond (and (= (count stack) 1) (= mid-small "mid")) (recur r [] nil (conj stack-lst f) k-v lst)
                               (and (> (count stack) 1) (= mid-small "mid")) (recur r (pop stack) "mid" (conj stack-lst f) k-v lst)
                               (not (= mid-small "mid")) (recur r stack mid-small (conj stack-lst f) k-v lst)
                               )
               (= f "}") (cond (and (= (count stack) 1) (= mid-small "big")) (recur r [] nil (conj stack-lst f) k-v lst)
                               (and (> (count stack) 1) (= mid-small "big")) (recur r (pop stack) "big" (conj stack-lst f) k-v lst)
                               (not (= mid-small "big")) (recur r stack mid-small (conj stack-lst f) k-v lst)
                               )
               (= f ":") (if (and (nil? mid-small) (empty? stack) (not (empty? stack-lst)))
                             (if (empty? k-v)
                                 (recur r [] nil [] (conj k-v stack-lst) lst)
                                 (let [vs-pair (get-vs-pair stack-lst)]
                                     (if (empty? vs-pair)
                                         (recur r [] nil [] [] (conj lst (conj k-v stack-lst)))
                                         (if (empty? (last vs-pair))
                                             (recur r [] nil [] [] (conj lst (conj k-v stack-lst)))
                                             (recur r [] nil [] [(last vs-pair)] (conj lst (conj k-v (first vs-pair))))))))
                             (recur r stack mid-small (conj stack-lst f) k-v lst))
               (my-lexical/is-eq? f "else") (if (and (nil? mid-small) (empty? stack) (not (empty? stack-lst)))
                                                (if-not (empty? k-v)
                                                    (recur r [] nil [] [["else"]] (conj lst (conj k-v stack-lst)))
                                                    (throw (Exception. "match 语句块中，不能只有 else")))
                                                (recur r stack mid-small (conj stack-lst f) k-v lst))
               :else
               (recur r stack mid-small (conj stack-lst f) k-v lst)
               )
         (if (and (not (empty? k-v)) (not (empty? stack-lst)))
             (conj lst (conj k-v stack-lst))
             lst))))

(split-pair-item-ex (my-lexical/to-back "(notEmpty?(rs.nth(0)) and notEmpty?(rs.nth(1))): concat(quickSort(rs.nth(0)), [lst.first()], quickSort(rs.nth(1)));\n        (notEmpty?(rs.nth(0)) and empty?(rs.nth(1))): concat(quickSort(rs.nth(0)), [lst.first()]);\n        (empty?(rs.nth(0)) and notEmpty?(rs.nth(1))): concat([lst.first()], quickSort(rs.nth(1)));\n        else [lst.first()];"))
(println "OK")