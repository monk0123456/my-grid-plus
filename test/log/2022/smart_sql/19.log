(def smart-sql "function my_test(a, b)\n{\n   let c = 10;\n   let d = [1, 2+3*4];\n   let tmp = c + d.get(1);\n   log(\"简单的四则运算\");\n   a + b + tmp;\n}")
(import (org.gridgain.smart MyVar MyLetLayer))

(def ast (first (my-smart-sql/get-ast smart-sql)))
(def func-name (-> ast :func-name))
(def args-lst (-> ast :args-lst))
(def body-lst (-> ast :body-lst))
;(-> ast :body-lst)
[(first body-lst) (second body-lst) (second (rest body-lst))]
(def lst-rs [(first body-lst) (second body-lst) (second (rest body-lst))])

(def my-context {:input-params #{} :let-params {} :last-item nil :inner-func #{} :up-my-context nil})
(def func-context (assoc my-context :input-params (apply conj (-> my-context :input-params) (-> ast :args-lst))))

(defn let-to-clj
    ([ignite group_id lst-let my-context] (let-to-clj ignite group_id lst-let my-context (MyLetLayer.) []))
    ([ignite group_id [f & r] my-context letLayer up-lst]
     (if (some? f)
         (if (my-smart-clj/in-same-layer? up-lst f)
             (recur ignite group_id r (my-smart-token-clj/add-let-to-context (-> f :let-name) (-> f :let-vs) my-context) (.addLet letLayer (format "%s (MyVar. %s)" (-> f :let-name) (my-smart-clj/token-to-clj ignite group_id (-> f :let-vs) my-context))) (conj up-lst f))
             (recur ignite group_id r (my-smart-token-clj/add-let-to-context (-> f :let-name) (-> f :let-vs) my-context) (MyLetLayer. (doto (ArrayList.) (.add (format "%s (MyVar. %s)" (-> f :let-name) (my-smart-clj/token-to-clj ignite group_id (-> f :let-vs) my-context)))) letLayer) [f])
             )
         (conj (my-smart-clj/letLayer-to-clj letLayer) my-context))))

(last (-> (second (rest body-lst)) :let-vs :operation))
(my-smart-token-clj/smart-func-to-clj ignite 0 (last (-> (second (rest body-lst)) :let-vs :operation)) func-context)
;(let-to-clj ignite 0 lst-rs func-context)


(def line "INSERT INTO categories (categoryid, categoryname, description) VALUES (?*(?+1+?), '白酒', ?)")
=> #'user/line
(str/replace line #"\?" "%s")
=> "INSERT INTO categories (categoryid, categoryname, description) VALUES (%s*(%s+1+%s), '白酒', '喝的')"

(def args [1 2 3.5 "吴大富"])


((eval (read-string "(fn [a & b]\n     (apply + a b))")) 1 2 3 4 5 6)