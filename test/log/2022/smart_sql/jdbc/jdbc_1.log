(declare smart-lst-to-clj get-smart-lst eval-codes)

(defn get-smart-lst [^Ignite ignite ^Long group_id ^String userToken ^clojure.lang.LazySeq lst]
    (loop [[f & r] (my-smart-sql/get-smart-segment lst) lst-rs []]
        (if (some? f)
            (cond (my-lexical/is-eq? (first f) "function") (recur r (conj lst-rs {:stm-type "function" :sql (my-smart-clj/my-smart-lst-to-clj ignite group_id f)}))
                  :else
                  (let [express-obj-root (first (my-smart-sql/body-segment f))]
                      (let [express-obj (my-smart-clj/re-ast userToken express-obj-root)]
                          (cond (and (contains? express-obj :expression) (my-lexical/is-eq? (-> express-obj :expression) "for")) (cond (and (contains? (-> express-obj :args :tmp_val) :item_name) (contains? (-> express-obj :args :seq) :item_name)) (recur r (conj lst-rs {:stm-type "for" :sql (my-smart-clj/for-seq ignite group_id express-obj nil)}))
                                                                                                                                       (and (contains? (-> express-obj :args :tmp_val) :item_name) (contains? (-> express-obj :args :seq) :func-name)) (recur r (conj lst-rs {:stm-type "for" :sql (my-smart-clj/for-seq-func ignite group_id express-obj nil)}))
                                                                                                                                       :else
                                                                                                                                       (throw (Exception. "for 语句只能处理数据库结果或者是列表"))
                                                                                                                                       )
                                (and (contains? express-obj :expression) (my-lexical/is-eq? (-> express-obj :expression) "match")) (recur r (conj lst-rs {:stm-type "match" :sql (format "(cond %s)" (my-smart-clj/match-to-clj ignite group_id (-> express-obj :pairs) nil))}))

                                (contains? express-obj :express) (recur r (conj lst-rs {:stm-type "other" :sql (my-smart-clj/token-to-clj ignite group_id (-> express-obj :express) nil)}))
                                (contains? express-obj :let-name) (recur r (conj lst-rs {:stm-type "let" :let-name (-> express-obj-root :let-name) :sql (format "(def %s (MyVar. %s))" (-> express-obj :let-name) (my-smart-clj/token-to-clj ignite group_id (-> express-obj :let-vs) nil))}))
                                :else
                                (throw (Exception. (format "代码错误！%s" (str/join " " f))))
                                )))
                  )
            lst-rs)))
(defn eval-codes [lst]
    (loop [[f & r] lst]
        (if (some? f)
            (if-not (nil? r)
                (do
                    (eval (read-string (-> f :sql)))
                    (recur r))
                (cond (= (-> f :stm-type) "let") (do
                                                     (eval (read-string (-> f :sql)))
                                                     (format "select show_msg('%s') as tip;" (-> f :let-name)))
                      :else
                      (do
                          (println (-> f :sql))
                          (format "select show_msg('%s') as tip;" (my-smart-clj/gson (eval (read-string (-> f :sql))))))
                      )))))

(defn smart-lst-to-clj [^Ignite ignite ^Long group_id ^String userToken ^clojure.lang.LazySeq lst]
    (let [smart-lst (get-smart-lst ignite group_id userToken lst)]
        (eval-codes smart-lst)))

(smart-lst-to-clj ignite 0 "dafu" (my-lexical/to-back "match {\n    a > tmp: tmp*12;\n    else 100;\n}"))