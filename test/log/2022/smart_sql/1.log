1、输入用户名，密码
如果成功就返回 {is_long: true, userToken: "XXX"}
如果错误就返回 {is_long: false, errMsg: "XXX"}

-- 开发一个函数，要求只返回第一条数据
function getFirst (sql, args)
{
   let lst = query_sql(sql, args);
   innerFunction {
       function notNil(rs)
       {
           match {
              rs <> nil:
                        log("执行成功！");
                        true;
              else
                  false;
           }
       }

       function myCase(rs)
       {
           match {
              rs.nth(1) == true: true;
              else
                   false;
           }
       }
   }
   for (rs in lst)
   {
      match {
         (notNil(rs)):
                       log("wudafu");
                       rs;
         my-case(rs):
                       log("这个是例子");
                       let sb = c + d;
                        a+b + f(sb);
         else
                       println("吴大富是帅哥！");
      }
      break;
   }
}

function my_test(a, b)
{
   let c = 10;
   a + b +c;
}

function public.login (username, passwrod)
{

}


; 定义语法的对象
{
    expression: "let",
    name: lst,
    value: query_sql(sql, args)
},
{
    expression: "for",
    args: {
        tmp_val: rs,
        seq: lst
    },
    body: [
        {
            expression: "match",
            pair: [],
            else: {}
        },
        {
            expression: "break"
        }
    ]
}


(defn get-small [lst]
    (if (= (first lst) "(")
        (letfn [(get-small-lst
                    ([lst] (get-small-lst lst [] []))
                    ([[f & r] stack stack-lst]
                     (if (some? f)
                         (cond (and (= f "(") (empty? stack)) (recur r (conj stack f) stack-lst)
                               (and (= f "(") (not (empty? stack))) (recur r (conj stack f) (conj stack-lst f))
                               (and (= f ")") (> (count stack) 1)) (recur r (pop stack) (conj stack-lst f))
                               (and (= f ")") (= (count stack) 1)) {:args-lst stack-lst :body-lst r}
                               :else
                               (recur r stack (conj stack-lst f))
                               )
                         (throw (Exception. "Smart 脚本错误！请仔细检查！"))))
                    )]
            (get-small-lst lst))))

(defn get-big [lst]
    (if (= (first lst) "{")
        (letfn [(get-big-lst
                    ([lst] (get-big-lst lst [] []))
                    ([[f & r] stack stack-lst]
                     (if (some? f)
                         (cond (and (= f "{") (empty? stack)) (recur r (conj stack f) stack-lst)
                               (and (= f "{") (not (empty? stack))) (recur r (conj stack f) (conj stack-lst f))
                               (and (= f "}") (> (count stack) 1)) (recur r (pop stack) (conj stack-lst f))
                               (and (= f "}") (= (count stack) 1)) {:big-lst stack-lst :rest-lst r}
                               :else
                               (recur r stack (conj stack-lst f))
                               )
                         (throw (Exception. "Smart 脚本错误！请仔细检查！"))))
                    )]
            (get-big-lst lst))))

(defn get-for-in-args [lst]
    (if (my-lexical/is-eq? (second lst) "in")
        {:tmp_val (first lst) :seq (rest (rest lst))}))

(defn body-segment
    ([lst] (body-segment (my-lexical/get-contain-lst lst) [] [] []))
    ([[f & r] stack stack-lst lst]
     (if (some? f)
         (cond (and (empty? stack) (my-lexical/is-eq? f "for") (= (first r) "(")) (let [{args-lst :args-lst body-lst :body-lst} (get-small r)]
                                                                                      (if-not (empty? body-lst)
                                                                                          (let [{big-lst :big-lst rest-lst :rest-lst} (get-big body-lst)]
                                                                                              (recur rest-lst [] [] (conj lst {:expression "for" :args (get-for-in-args args-lst) :body (body-segment big-lst)})))))
               (and (empty? stack) (my-lexical/is-eq? f "match") (= (first r) "{")) (let [{big-lst :big-lst rest-lst :rest-lst} (get-big r)]
                                                                                         (recur rest-lst [] [] (conj lst {:expression "match" :pair (body-segment big-lst)})))


               ))))



(def line "function getFirst (sql, args)\n{\n   let lst = query_sql(sql, args);\n   for (rs in lst)\n   {\n      match {\n         (notNil(rs)): rs;\n         else println();\n      }\n      break;\n   }\n}")
(def lst (my-lexical/to-back line))

(def body-lst (-> (get-func-name lst) :body-lst))
(-> (get-func-name lst) :body-lst)



(def lst (my-lexical/to-back "function getFirst (sql, args)\n{\n   let lst = query_sql(sql, args);\n   for (rs in lst)\n   {\n      b = a + c;\n      match {\n         (notNil(rs)): rs;\n         (a +b > 100): println(\"吴大富是帅哥1\");\n         else println(\"吴大贵是美女！\");\n      }\n      break;\n   }\n}"))
(def body-lst (-> (my-smart-sql/get-func-name lst) :body-lst))
(defn body-segment
    ([lst] (body-segment lst [] []))
    ([[f & r] stack-lst lst]
     (if (some? f)
         (cond (and (empty? stack-lst) (my-lexical/is-eq? f "for") (= (first r) "(")) (let [{args-lst :args-lst body-lst :body-lst} (my-smart-sql/get-small r)]
                                                                                          (if-not (empty? body-lst)
                                                                                              (let [{big-lst :big-lst rest-lst :rest-lst} (my-smart-sql/get-big body-lst)]
                                                                                                  (recur rest-lst [] (conj lst {:expression "for" :args (my-smart-sql/get-for-in-args args-lst) :body (body-segment big-lst)})))))
               (and (empty? stack-lst) (my-lexical/is-eq? f "match") (= (first r) "{")) (let [{big-lst :big-lst rest-lst :rest-lst} (my-smart-sql/get-big r)]
                                                                                             (recur rest-lst [] (conj lst {:expression "match" :pair (body-segment big-lst)})))
               (= f ";") (recur r [] (conj lst stack-lst))
               :else
               (recur r (conj stack-lst f) lst)
               )
         lst)))

(body-segment (my-lexical/get-contain-lst body-lst))















(my-lexical/get-contain-lst lst)